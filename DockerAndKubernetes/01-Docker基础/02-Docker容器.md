# Docker 容器



## 容器和虚拟机的区别

**虚拟机模型**

首先要开启物理机并启动 Hypervisor 引导程序，Hypervisor 是硬件虚拟化，是将硬件物理资源划分为虚拟资源，每个虚拟机都是包含了虚拟 CPU、虚拟 RAM、虚拟磁盘等资源的一种软件结构，都需要有自己的操作系统来声明、初始化并管理这些虚拟资源，因此每个虚拟机的操作系统都会占用一定资源，存在着多份 OS 损耗。启动一个虚拟机要包括启动操作系统的时间，因此启动时间也更长。

**容器模型**

容器是操作系统虚拟化，是将系统资源划分为虚拟资源，多个容器共享一个操作系统内核，也就是说，只有一个操作系统在消耗 CPU、RAM 和存储资源，多个容器只有一份 OS 损耗。并且容器并不是一个完整的操作系统，其启动时间要远少于虚拟机。



## container 常用命令

这些命令都是既可以通过 container-name 又可以通过 container-id 来指定具体容器。

```sh
# ---------------------------------------------------------------------------------------- #
# 启动新容器
# --name 指定别名
# -it 使我们可以与容器进行交互
# /bin/bash 是我们要运行的命令
docker container run --name my_container -it ubuntu /bin/bash

# 可以使用 -e 参数给容器设置环境变量，这样可以方便的从环境变量中读取配置，也可方便的在启动容器时对配置进行修改
docker run -d -p 5000:5000 --link redis --name test1 -e REDIS_HOST=redis flask-redis
# ---------------------------------------------------------------------------------------- #

# 可以使用 Ctrl-PQ 断开与容器的连接，不过不会 stop 容器

# ---------------------------------------------------------------------------------------- #
# 列出所有在运行的容器
docker container ls
docker ps

# -a 参数可以列出已经 Exited 的容器
docker container ls -a
docker ps -a
# ---------------------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------------------- #
# 允许用户在已经启动的容器中启动一个进程（有用极了！）
docker container exec
docker container exec -it <container-name or container-id> /bin/bash
# ---------------------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------------------- #
# 停止运行中的容器，将容器的状态置为 Exited(0)
docker container stop
# ---------------------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------------------- #
# 启动处于 Exited(0) 状态的容器
docker container start
# ---------------------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------------------- #
# 删除停止运行的容器
docker container rm

# -f 参数可以删除正在运行的容器
docker container rm <container-name or container-id> -f
# ---------------------------------------------------------------------------------------- #

# ---------------------------------------------------------------------------------------- #
# 显示容器的配置细节和运行时信息
docker container inspect
# ---------------------------------------------------------------------------------------- #
```

**注意：** 杀死容器中的主进程，容器也会被杀死。



## 优雅的停止容器

一般如果我们想要优雅的停止容器，我们可以使用 `docker container stop` 命令，stop 命令会向容器内 PID 1 进程发送一个 **SIGMENT** 信号，这会为进程预留一个清理并优雅停止的时间。如果 10s 后进程还是没有终止，才会收到 **SIGKILL** 信号，进程会直接被停止，也就是说，使用 stop 来停止容器，容器进程起码有了 10s 的时间来 “处理” 自己。

还有一种不优雅的容器删除方式，那就是 `docker rm <container> -f`，这个命令会直接向容器内的 PID 1 进程发送 **SIGKILL** 信号，直接干掉容器进程，不会给它留下 10s 说遗言。

此外，如果我们在非生产环境下想要来个痛快的，可以使用以下命令删除主机上所有容器：

```shell
docker rm $(docker ps -aq) -f
```



## 利用重启策略进行容器的自我修复

通常建议在运行容器时配置好重启策略，来增强容器的稳定性，可以指定事件或者错误后重启容器来完成自我修复。

容器支持的重启策略包括：`always`，`unless-stop` 和 `on-failed`。

使用了 `--restart always` 策略的容器除非使用 stop 命令明确停止，否则它会一处于停止状态就会直尝试重启。并且当 daemon 重启时，停止的容器也会被重启。

`unless-stopped` 基本和 `always` 差不多，区别在于 daemon 重启时，不会重启那些制定了 `--restart unless-stopped` 并处于 Exited 状态的容器。

`on-failed` 策略会在退出容器的返回值不是 0 时重启容器，并且在该策略下，daemon 重启时，停止的容器也会被重启。