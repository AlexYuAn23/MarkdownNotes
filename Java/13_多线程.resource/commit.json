{"compress":true,"commitItems":[["e3d04df3-3ef0-493c-8c5a-0d92446977d5",1512200464357,"\n# 多线程\n\n## 进程 & 线程\n\n### 进程\n- 正在进行中的程序\n\n### 线程\n- **进程中**一个负责**程序执行的控制单元**(执行路径)\n- 一个进程中至少要有一个线程（否则这个进程根本没有存在的意义）\n- 多线程\n    - 一个进程中有多个执行路径\n    - 为了同时运行多部分代码，每个线程都运行自己要执行的任务\n\n## 多线程的优缺点\n- 优点：解决了多部分同时运行的问题\n- 缺点：线程太多回到效率的降低\n- 原因：**其实应用程序的同时执行都是 CPU 在做着快速的切换完成的，这个切换是随机的，也就是说，一个 CPU 在一个时刻只执行一个线程**\n\n## JVM中的多线程 [重要]\n- JVM启动时就启动了多个线程，至少可以分析出一下两个线程\n    - 执行main函数的线程\n    - 负责垃圾回收的线程\n- 在`Object`中有个`protected void finalize()`方法，当对象没有引用时 called garbage collector 回收它自己\n- e.g.\n\n```\nclass Demo extends Object\n{\n\tpublic void finalize()\n\t{\n\t\tSystem.out.println(\"demo ok\");\n\t}\n}\n\nclass  ThreadDemo\n{\n\tpublic static void main(String[] args) \n\t{\n\n\t\tnew Demo();\n\t\tnew Demo();\n\t\tnew Demo();\n\t\tSystem.gc();  // Runs the garbage collector\n\t\tSystem.out.println(\"Hello World!\");\n\t}\n}\n\nOutput:\nHello World!\ndemo ok\ndemo ok\ndemo ok\n```\n\n- Example 中`System.out.println(\"Hello World!\");`先执行了，是因为**垃圾回收和主函数是两个不同的线程在运行，而主线程执行的快些**\n- 有时也会出现这种情况，因为垃圾回收线程还没运行完，整个进程结束了，进程中的线程都被清理掉了\n\n```\nOutput:\nHello World!\ndemo ok\n```\n\n## 线程的创建 [重要]\n\n### 方式一：继承 Thread 类\n##### 步骤：\n- 定义一个类继承 Thread 类\n- 覆盖 Thread 类中的 run 方法\n- 直接创建 Thread 的子类对象创建线程\n- 调用 start 方法开启线程并调用线程的任务 run 方法执行\n\n**e.g.** [ThreadDemo0](13_多线程/ThreadDemo0.txt)\n\n##### Note：\n- Thread 类用于描述线程，线程是需要任务的，所以Thread类也要有对任务的描述，写在`public void run()`方法中\n- 直接调用`run()`方法并不能创建线程，要调用`start()`方法，通过`start()`方法调用`run()`方法才会创建新的线程\n- 在例子中创建了两个线程，再加上一个主线程，在例子中主线程会在另外两个线程之前结束\n- **获取线程的名称`getName()`，注意：线程的名称在创建线程的对象时就在其父类`Thread`中定义了，命名规则：Thread-编号(从0开始)**\n- 也可以在构造器中改调用`super(name)`方法，可以自己给线程起名字\n- 主线程的名字就是 main\n- **获取当前正在运行的线程的方法`static Thread currentThread()`，静态方法直接调用`Thread.currentThread()`**\n- 对比`start()`和`run()`的区别\n    - **e.g.** [ThreadDemo1](13_多线程/ThreadDemo1.txt)\n    \n##### 多线程运行内存图解\n- 解释了为什么`main`函数弹栈了`run`方法还能运行，因为每个线程有它自己的栈，一个线程运行完后释放自己的栈，不影响其他线程\n![](13_多线程/多线程运行图.gif)\n\n\n### 方式二：实现 Runnable 接口\n\nRunnable 接口中只有一个`run()`方法\n\n##### 步骤\n- 定义类实现`Runnable`接口\n- 覆盖接口中的`run`方法，将线程的任务代码封装到`run`方法中\n- 通过`Thread`类创建线程对象，并将`Runnable`接口的子类对象作为`Thread`类的构造函数的参数进行传递\n\n```\nclass Demo implements Runnable {\n\tpublic void run() {\n\t\tshow();\n\t}\n\tpublic void show() {\n\t\tfor(int x=0; x<20; x++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\".....\"+x);\n\t\t}\n\t}\n}\n\nDemo d = new Demo();\nThread t1 = new Thread(d);  // 通过 Thread 类创建线程对象\n```\n\n- 调用线程对象的`start`方法开启线程\n\n##### Thread 类的结构\nThread 类也实现了 Runnable 接口\n```\nclass Thread {\n    private Runnable r;\n    \n    public Thread() {\n    \n    }\n    \n    public Thread(Runnable r) {\n        this.r = r;\n    }\n    \n    public void run() {\n        if (r != null)\n            r.run();\n    }\n    \n    public void start() {\n        run();\n    }\n}\n```\n\n##### 优点\n- 将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务的封装成对象\n- 避免了 java 单继承的局限性。\n\n## 多线程状态图 [重要]\n\n![](13_多线程/多线程状态图.gif)\n\n## 买票实例（4个窗口卖一种票）[重要]\n\n- **不能多次启动同一个线程，会触发`IllegalThreadStateException`异常**\n```\nt1.start();\nt1.start();  // 非法\n```\n\n- **实现方法：实现 Runnable 接口**\n\n```\nclass Ticket implements Runnable {\n    private int num;\n    \n    public void run() {\n        while(true) {\n            if (num > 0) {\n                try {\n                    Thread.sleep(10);\n                } catch(InterruptedException e) {\n                    // 因为Runnable接口中的run方法并没有抛出异常，所以这个异常只能catch，不能throws\n                }\n                \n                // 加了sleep(10)后，可能4个线程同时通过了if (num > 0)的检查判断，从而导致num变为复数\n                System.out.println(Thread.currentThread().getName() + \"...sale...\" + num--);\n            }\n        }\n    }\n}\n\nclass  TicketDemo {\n\tpublic static void main(String[] args) {\n\n\t\tTicket t = new Ticket();  // 就这一个对象，所以只有100张票\n\n\t\tThread t1 = new Thread(t);\n\t\tThread t2 = new Thread(t);\n\t\tThread t3 = new Thread(t);\n\t\tThread t4 = new Thread(t);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\t\tt4.start();\n    }\n}\n```\n\n## 线程安全问题 [重要]\n\n**NOTE：上面代码 class Ticket 中的 run() 方法就会出现线程安全问题**\n\n### 线程安全问题产生的原因\n- 多个线程在操作共享数据\n- **操作共享数据的线程代码有多行**\n    - 即当一个线程在执行操作共享数据的**多行**代码时，**其他线程参与了运算**，就会导致线程安全问题的产生\n\n\n### 解决思路\n- **将多条操作共享数据的线程代码封装起来**，当有线程在执行这些代码的时候，其他线程时不可以参与运算的，必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算\n\n\n### 线程安全问题的判断\n- **看在线程运行的代码中是否有共享数据，即`run()`中是否有共享数据**\n\n\n### 使用工具1 -- 同步代码块\n##### 同步代码块格式\n```\nsynchronized(对象) {\n    需要被同步的代码;\n}\n```\n\n##### e.g.\n```\nObject obj = new Object();\n\npublic void run() {\n    synchronized(obj) {\n        ...\n    }\n}\n```\n\n\n#### 同步代码块原理\n\n- `synchronized(obj)`中，`obj`就是一个同步锁，当有一个线程进入到存在线程安全问题的多行代码中时，这个线程就会持有这个同步锁，其他的线程因为拿不到同步锁就无法进入同步代码块\n\n#### 同步代码块的优缺点 & 前提\n- **优点：**解决了线程的安全问题\n- **缺点：**相对降低了效率，因为同步外的线程的都会判断同步锁\n- **前提：**同步中必须有**多个线程**并使用**同一个锁**\n    - 所以`Object obj = new Object()`要在`run()`方法外面，因为如果在`run()`方法里面，就会是每个线程有一个同步锁，不再满足同一个锁的前提，仍会出现线程安全问题\n\n\n### 使用工具2 -- 同步函数\n- 当需要封装进同步代码块的代码直接就是一个函数中的全部代码时，就直接把这个函数用关键字`synchronized`定义为同步函数进行简写\n- **同步函数的同步锁是`this`**\n    - 相当于\n    ```\n    synchronized(this) {\n        ...\n    }\n    ```\n- **静态同步函数的同步锁**\n    - 该函数所属字节码文件对象，可以用`getClass`方法获取，也可以用当前`类名.class`表示\n    - 相当于\n    ```\n    synchronized(this.getClass / Ticket.class) {\n        ...\n    }\n    ```\n\n### 同步代码块与同步函数的区别\n- 同步函数的锁是固定的`this`\n- 同步代码块的锁可以是任意的对象\n\n*建议使用同步代码块*\n\n## 单例模式的多线程问题 [重要]\n\n```\nclass Single {\n    private static Single s;\n    private Single(){}\n    \n    public static Single getInstance() {\n        if (s == null)\n            -->0 -->1  // 两个线程同时到了这，就会 new 两个对象出来，产生线程安全问题\n            s = new Single();\n        return s;\n    }\n}\n```\n\n##### 解决方法\n\n```\nclass Single {\n    private static Single s;\n    private Single(){}\n    \n    public static Single getInstance() {\n        if (s == null) {                  // 外面的这个 if 判断解决了要进行同步锁判断的效率问题\n            synchronized(Single.class) {  // synchronized 解决了线程安全问题\n                if (s == null)\n                    s = new Single();\n            }\n        }\n        return s;\n    }\n}\n```\n\n## 死锁 [重要]\n\n- 常见情形：同步的嵌套 & 多个锁，不同线程各持一个锁在等待另一个锁，并且都不放开自己已经持有的锁\n- 死锁示例：[DeadLockTest](13_多线程/DeadLockTest.txt)\n\n## 线程间的通信 [重要]\n\n多个线程在处理同一资源，但是任务却不同\n\n\n### 等待唤醒机制\n\n##### 用到的方法（注意：这些方法都必须定义在同步中）\n- `wait()`：让线程处于冻结状态，被`wait()`的线程会被存储到线程池中\n- `notify()`：唤醒线程池中一个线程**(任意)**\n- `notifyAll()`：唤醒线程池中的所有线程\n\n##### NOTE\n- **这些方法都必须定义在同步中**\n    - 原因：因为这些方法是用于操作线程状态的方法，必须要明确**操作的是哪个锁上的线程**，所以这些方法其实是**调用了锁的方法**\n- 因为是调用了锁的方法，所以它们都定义在了`Object`类中\n    - 原因：因为锁可以是任意的对象，任意的对象调用的方式一定定义在`Object`类中\n    \n##### Example（单生产者单消费者问题）\n- 原始版：[ResourceDemo](13_多线程/ResourceDemo.txt)\n- 优化版：[OptimizedResourceDemo](13_多线程/OptimizedResourceDemo.txt)\n\n\n### 多生产者多消费者问题\n\n#### 出现的问题\n##### 问题一\n```\nif (flag)\n    try {wait();} catch (InterruptedException e) {}\n...\n```\n在`wait()`处休眠的线程再次被唤醒后，不会再判断`flag`的值，而是直接往下运行，会导致不该运行的线程运行，出现数据错误的情况\n\n##### 解决方法\n```\nwhile (flag)\n    try {wait();} catch (InterruptedException e) {}\n...\n```\n采用`while`判断标记\n\n##### 问题二\n`notify()`与`while(flag)`的搭配会导致死锁\n\n##### 解决方法\n采用`notifyAll()`解决了本方线程一定会唤醒对方线程的问题\n\n#### Example\n[ProducerConsumerDemo](13_多线程/ProducerConsumerDemo.txt)\n\n\n### jdk1.5 后对多线程的改进\n- `synchronized`中对于锁的操作是隐式的，jdk1.5 以后将同步和锁封装成了对象，将隐式动作变成了显示动作\n- `Lock`接口：替代了同步代码块或者同步函数，将同步的隐式锁操作变成现实锁操作，并且可以在一个锁上加上多组监视器\n    - `lock()`：获取锁。\n    - `unlock()`：释放锁，通常需要定义finally代码块中\n\n```\nLock l = ...;\n\nl.lock();\ntry {\n    // access the resource protected by this lock\n} finally {\n    l.unlock();\n}\n```\n- `Condition`接口：出现替代了`Object`中的`wait()` `notify()` `notifyAll()`方法，将这些监视器方法单独进行了封装，变成`Condition`监视器对象\n    - 替换方法为`await()` `signal()` `signalAll()`\n    \n#### Example\n[JDK1_5_ProducerConsumerDemo](13_多线程/JDK1_5_ProducerConsumerDemo.txt)\n\n#### Docs Example\n```\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## `wait()`和`sleep()`的区别\n\n- `wait()`可以指定时间也可以不指定，`sleep()`必须指定时间\n- 在同步中时，对 CPU 的执行权和锁的处理不同\n    - `wait()`：释放执行权，释放锁\n    - `sleep()`：释放执行权，不释放锁\n\n## 同步的注意事项\n\n- 同步代码块中可以存活多个线程，但运行的只有一个线程，因为只有一个线程可以拿到锁\n\n```\nclass Demo {\n\tvoid show() {\n\t\tsynchronized(this) {\n\t\t\twait(); // t0 t1 t2 三个线程都在同步代码块中存活，但运行时还是要一个一个运行的\n\t\t}\n\t}\n    \n\tvoid method() {\n\t\tsynchronized(this) { // t4\n\t\t\tnotifyAll();\n\t\t}\n\t}\n}\n```\n\n\n## 停止线程\n\n- `stop()`方法（官方的不推荐使用）\n- `run()`方法结束\n\n##### 怎么控制线程的任务结束呢?\n- 任务中都会有循环结构，只要控制住循环就可以结束任务\n- 控制循环通常就用定义标记来完成\n\n```\nprivate boolean flag;\n\npublic synchronized void run() {\n    while (flag) {\n    ...\n    }\n}\n```\n\n##### 但是如果线程处于了冻结状态，无法读取标记，那应该如何结束呢？\n- 可以使用`interrupt()`方法将线程从冻结状态强制恢复到运行状态中来，让线程具备 cpu 的执行资格\n- 但强制的`interrupt()`动作会抛出`InterruptedException`，记得要处理\n\n##### Example\n[StopThread](13_多线程/StopThread.txt)\n\n## 官方不推荐使用`stop()`和`suspend()`的原因\n### 不推荐使用`stop()`的原因\n- 因为它不安全，会造成数据的不完整\n- 说明\n    - `stop()`会解除由线程获取的所有锁定，当在一个线程对象上调用`stop()`方法时，这个线程对象所运行的线程就会立即停止\n    - 假如一个线程正在执行：`synchronized void { x = 3; y = 4;}`，由于方法是同步的，多个线程访问时总能保证 x，y 被同时赋值，而如果一个线程正在执行到`x = 3;`时，被调用了`stop()`方法，即使在同步块中，它也干脆地 stop 了，这样就产生了不完整的残废数据\n    - 而多线程编程中最最基础的条件是要保证数据的完整性\n\n### 不推荐使用`suspend()`的原因\n- 因为它容易发生死锁\n- 说明\n    - 调用`suspend()`的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定\n    - 此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行\n    - 对任何线程来说，如果它们想恢复目标线程，同时又试图使用一个锁定的资源，就会造成死锁\n\n## 守护线程（后台线程）\n**`setDaemon()`**\n\n- 当所有剩余运行的线程都是守护线程（后台线程）后，java 虚拟机会退出执行\n    - 即所有的前台线程都结束后，剩下的后台线程就自动结束了\n- 为什么叫“守护线程”\n    - 来自圣斗士星矢，星矢是守护雅典娜的，雅典娜就是前台线程，星矢就是守护线程，如果雅典娜都没了，星矢自然就没有存在的必要了\n- 例子：`t1`和`main`线程结束后，`t2`线程自动结束\n\n```\nStopThread st = new StopThread();\n\nThread t1 = new Thread(st);\nThread t2 = new Thread(st);\n\nt1.start();\nt2.setDaemon(true);\nt2.start();\n```\n\n\n\n## `join()`方法\n\n```\nt0.join();\n```\n\n- `t0`线程要申请加入进来运行\n- 用在临时加入一个线程运算时\n- `join()`方法会使当前运行的线程冻结，直到调用`join()`方法的线程运行完毕后，才再次开始运行\n- 因为有冻结线程的能力，所以会抛出`InterruptedException`异常\n\n## `toString()`方法\n\n##### 输出\n```\nThread[线程名，优先级，线程组]\n```\n\n##### 优先级\n- 优先级范围 1~10，6 7 差距不大，但 1 5 10 差距就比较大了，优先级大只是这个线程的执行频率变高，并不是会一直执行这个线程直至结束\n\n```\nt2.setPriority(Thread.MAX_PRIORITY);\n```\n\n## `yield()`方法\n\n```\nThread.yield();  // 释放执行权\n```\n\n## 两个小问题\n\n##### 问题一\n```\nclass Test implements Runnable {\n\tpublic void run(Thread t){\n    }\n}\n```\n错在没有实现`Runnable`接口的方法\n\n##### 问题二\n```\nclass ThreadTest {\n\tpublic static void main(String[] args) {\n\n\t\tnew Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"runnable run\");\n\t\t\t}\n\t\t}) {\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"subThread run\");\n\t\t\t}\n\t\t}.start();\n    }\n}\n```\n输出：`subThread run`，因为以子类方法为主，而`public Thread(Runnable target)`构造器相当于将 Thread 的 parent 赋成 target\n",[[1512200464236,["user@user-PC",[[1,0,"---\nstyle: candy\n---\n"]],[2711,2711],[2732,2732]]],[1512200466066,["user@user-PC",[[-1,0,"---\nstyle: candy\n---\n"]],[2732,2732],[2711,2711]]],[1512200467369,["user@user-PC",[[1,0,"---\nstyle: candy\n---\n"]],[2711,2711],[2732,2732]]],[1512200469984,["user@user-PC",[[1,11,"o"],[1,12,"e"],[-1,14,"dy"]],[2732,2732],[2732,2732]]],[1512200471942,["user@user-PC",[[-1,11,"ocea"],[1,15,"plai"]],[2732,2732],[2732,2732]]],[1512200473527,["user@user-PC",[[-1,11,"plain"],[1,16,"summer"]],[2732,2732],[2733,2733]]],[1512200477269,["user@user-PC",[[-1,0,"---\nstyle: summer\n---\n"]],[2733,2733],[2711,2711]]],[1512200479853,["user@user-PC",[[1,0,"---\nstyle: candy\n---\n"]],[2711,2711],[2732,2732]]],[1512200482378,["user@user-PC",[[1,11,"o"],[1,12,"e"],[-1,14,"dy"]],[2732,2732],[2732,2732]]],[1512200484370,["user@user-PC",[[-1,11,"ocea"],[1,15,"plai"]],[2732,2732],[2732,2732]]],[1512200488794,["user@user-PC",[[-1,11,"plai"],[1,15,"ocea"]],[2732,2732],[2732,2732]]],[1512200490919,["user@user-PC",[[-1,11,"ocea"],[1,15,"plai"]],[2732,2732],[2732,2732]]],[1512200491874,["user@user-PC",[[-1,11,"plai"],[1,15,"ocea"]],[2732,2732],[2732,2732]]],[1512200492786,["user@user-PC",[[-1,11,"o"],[-1,13,"e"],[1,16,"dy"]],[2732,2732],[2732,2732]]],[1512200494436,["user@user-PC",[[1,11,"o"],[1,12,"e"],[-1,14,"dy"]],[2732,2732],[2732,2732]]],[1512200495710,["user@user-PC",[[-1,11,"o"],[-1,13,"e"],[1,16,"dy"]],[2732,2732],[2732,2732]]],[1512200497573,["user@user-PC",[[-1,0,"---\nstyle: candy\n---\n"]],[2732,2732],[2711,2711]]],[1512200500839,["user@user-PC",[[1,0,"---\nstyle: candy\n---\n"]],[2711,2711],[2732,2732]]],[1512200502312,["user@user-PC",[[1,11,"o"],[1,12,"e"],[-1,14,"dy"]],[2732,2732],[2732,2732]]],[1512200503620,["user@user-PC",[[-1,11,"o"],[-1,13,"e"],[1,16,"dy"]],[2732,2732],[2732,2732]]],[1512200576071,["user@user-PC",[[1,21,"[]"]],[21,21],[23,23]]],[1512200578464,["user@user-PC",[[1,22,"TOC"]],[22,22],[25,25]]],[1512200582933,["user@user-PC",[[1,27,"\n"]],[26,26],[27,27]]],[1512200586234,["user@user-PC",[[-1,22,"TOC"]],[25,25],[22,22]]],[1512200587420,["user@user-PC",[[1,22,"toc"]],[22,22],[25,25]]],[1512200597003,["user@user-PC",[[-1,21,"[toc]"]],[21,26],[21,21]]],[1512200597239,["user@user-PC",[[-1,22,"\n"]],[21,21],[20,20]]],[1512200690119,["user@user-PC",[[1,21,"[]"]],[21,21],[23,23]]],[1512200692337,["user@user-PC",[[1,22,"TOC"]],[22,22],[25,25]]],[1512200693343,["user@user-PC",[[1,27,"\n"]],[26,26],[27,27]]],[1512200708683,["user@user-PC",[[-1,21,"[TOC]\n"]],[21,27],[21,21]]],[1512200709261,["user@user-PC",[[-1,21,"\n"]],[21,21],[20,20]]]]],["1d79ad1b-59d5-4a0a-97af-d297e72f3280",1512705887612,"---\nstyle: candy\n---\n# 多线程\n\n## 进程 & 线程\n\n### 进程\n- 正在进行中的程序\n\n### 线程\n- **进程中**一个负责**程序执行的控制单元**(执行路径)\n- 一个进程中至少要有一个线程（否则这个进程根本没有存在的意义）\n- 多线程\n    - 一个进程中有多个执行路径\n    - 为了同时运行多部分代码，每个线程都运行自己要执行的任务\n\n## 多线程的优缺点\n- 优点：解决了多部分同时运行的问题\n- 缺点：线程太多回到效率的降低\n- 原因：**其实应用程序的同时执行都是 CPU 在做着快速的切换完成的，这个切换是随机的，也就是说，一个 CPU 在一个时刻只执行一个线程**\n\n## JVM中的多线程 [重要]\n- JVM启动时就启动了多个线程，至少可以分析出一下两个线程\n    - 执行main函数的线程\n    - 负责垃圾回收的线程\n- 在`Object`中有个`protected void finalize()`方法，当对象没有引用时 called garbage collector 回收它自己\n- e.g.\n\n```\nclass Demo extends Object\n{\n\tpublic void finalize()\n\t{\n\t\tSystem.out.println(\"demo ok\");\n\t}\n}\n\nclass  ThreadDemo\n{\n\tpublic static void main(String[] args) \n\t{\n\n\t\tnew Demo();\n\t\tnew Demo();\n\t\tnew Demo();\n\t\tSystem.gc();  // Runs the garbage collector\n\t\tSystem.out.println(\"Hello World!\");\n\t}\n}\n\nOutput:\nHello World!\ndemo ok\ndemo ok\ndemo ok\n```\n\n- Example 中`System.out.println(\"Hello World!\");`先执行了，是因为**垃圾回收和主函数是两个不同的线程在运行，而主线程执行的快些**\n- 有时也会出现这种情况，因为垃圾回收线程还没运行完，整个进程结束了，进程中的线程都被清理掉了\n\n```\nOutput:\nHello World!\ndemo ok\n```\n\n## 线程的创建 [重要]\n\n### 方式一：继承 Thread 类\n##### 步骤：\n- 定义一个类继承 Thread 类\n- 覆盖 Thread 类中的 run 方法\n- 直接创建 Thread 的子类对象创建线程\n- 调用 start 方法开启线程并调用线程的任务 run 方法执行\n\n**e.g.** [ThreadDemo0](13_多线程/ThreadDemo0.txt)\n\n##### Note：\n- Thread 类用于描述线程，线程是需要任务的，所以Thread类也要有对任务的描述，写在`public void run()`方法中\n- 直接调用`run()`方法并不能创建线程，要调用`start()`方法，通过`start()`方法调用`run()`方法才会创建新的线程\n- 在例子中创建了两个线程，再加上一个主线程，在例子中主线程会在另外两个线程之前结束\n- **获取线程的名称`getName()`，注意：线程的名称在创建线程的对象时就在其父类`Thread`中定义了，命名规则：Thread-编号(从0开始)**\n- 也可以在构造器中改调用`super(name)`方法，可以自己给线程起名字\n- 主线程的名字就是 main\n- **获取当前正在运行的线程的方法`static Thread currentThread()`，静态方法直接调用`Thread.currentThread()`**\n- 对比`start()`和`run()`的区别\n    - **e.g.** [ThreadDemo1](13_多线程/ThreadDemo1.txt)\n    \n##### 多线程运行内存图解\n- 解释了为什么`main`函数弹栈了`run`方法还能运行，因为每个线程有它自己的栈，一个线程运行完后释放自己的栈，不影响其他线程\n![](13_多线程/多线程运行图.gif)\n\n\n### 方式二：实现 Runnable 接口\n\nRunnable 接口中只有一个`run()`方法\n\n##### 步骤\n- 定义类实现`Runnable`接口\n- 覆盖接口中的`run`方法，将线程的任务代码封装到`run`方法中\n- 通过`Thread`类创建线程对象，并将`Runnable`接口的子类对象作为`Thread`类的构造函数的参数进行传递\n\n```\nclass Demo implements Runnable {\n\tpublic void run() {\n\t\tshow();\n\t}\n\tpublic void show() {\n\t\tfor(int x=0; x<20; x++) {\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\".....\"+x);\n\t\t}\n\t}\n}\n\nDemo d = new Demo();\nThread t1 = new Thread(d);  // 通过 Thread 类创建线程对象\n```\n\n- 调用线程对象的`start`方法开启线程\n\n##### Thread 类的结构\nThread 类也实现了 Runnable 接口\n```\nclass Thread {\n    private Runnable r;\n    \n    public Thread() {\n    \n    }\n    \n    public Thread(Runnable r) {\n        this.r = r;\n    }\n    \n    public void run() {\n        if (r != null)\n            r.run();\n    }\n    \n    public void start() {\n        run();\n    }\n}\n```\n\n##### 优点\n- 将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务的封装成对象\n- 避免了 java 单继承的局限性。\n\n## 多线程状态图 [重要]\n\n![](13_多线程/多线程状态图.gif)\n\n## 买票实例（4个窗口卖一种票）[重要]\n\n- **不能多次启动同一个线程，会触发`IllegalThreadStateException`异常**\n```\nt1.start();\nt1.start();  // 非法\n```\n\n- **实现方法：实现 Runnable 接口**\n\n```\nclass Ticket implements Runnable {\n    private int num;\n    \n    public void run() {\n        while(true) {\n            if (num > 0) {\n                try {\n                    Thread.sleep(10);\n                } catch(InterruptedException e) {\n                    // 因为Runnable接口中的run方法并没有抛出异常，所以这个异常只能catch，不能throws\n                }\n                \n                // 加了sleep(10)后，可能4个线程同时通过了if (num > 0)的检查判断，从而导致num变为复数\n                System.out.println(Thread.currentThread().getName() + \"...sale...\" + num--);\n            }\n        }\n    }\n}\n\nclass  TicketDemo {\n\tpublic static void main(String[] args) {\n\n\t\tTicket t = new Ticket();  // 就这一个对象，所以只有100张票\n\n\t\tThread t1 = new Thread(t);\n\t\tThread t2 = new Thread(t);\n\t\tThread t3 = new Thread(t);\n\t\tThread t4 = new Thread(t);\n\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\t\tt4.start();\n    }\n}\n```\n\n## 线程安全问题 [重要]\n\n**NOTE：上面代码 class Ticket 中的 run() 方法就会出现线程安全问题**\n\n### 线程安全问题产生的原因\n- 多个线程在操作共享数据\n- **操作共享数据的线程代码有多行**\n    - 即当一个线程在执行操作共享数据的**多行**代码时，**其他线程参与了运算**，就会导致线程安全问题的产生\n\n\n### 解决思路\n- **将多条操作共享数据的线程代码封装起来**，当有线程在执行这些代码的时候，其他线程时不可以参与运算的，必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算\n\n\n### 线程安全问题的判断\n- **看在线程运行的代码中是否有共享数据，即`run()`中是否有共享数据**\n\n\n### 使用工具1 -- 同步代码块\n##### 同步代码块格式\n```\nsynchronized(对象) {\n    需要被同步的代码;\n}\n```\n\n##### e.g.\n```\nObject obj = new Object();\n\npublic void run() {\n    synchronized(obj) {\n        ...\n    }\n}\n```\n\n\n#### 同步代码块原理\n\n- `synchronized(obj)`中，`obj`就是一个同步锁，当有一个线程进入到存在线程安全问题的多行代码中时，这个线程就会持有这个同步锁，其他的线程因为拿不到同步锁就无法进入同步代码块\n\n#### 同步代码块的优缺点 & 前提\n- **优点：**解决了线程的安全问题\n- **缺点：**相对降低了效率，因为同步外的线程的都会判断同步锁\n- **前提：**同步中必须有**多个线程**并使用**同一个锁**\n    - 所以`Object obj = new Object()`要在`run()`方法外面，因为如果在`run()`方法里面，就会是每个线程有一个同步锁，不再满足同一个锁的前提，仍会出现线程安全问题\n\n\n### 使用工具2 -- 同步函数\n- 当需要封装进同步代码块的代码直接就是一个函数中的全部代码时，就直接把这个函数用关键字`synchronized`定义为同步函数进行简写\n- **同步函数的同步锁是`this`**\n    - 相当于\n    ```\n    synchronized(this) {\n        ...\n    }\n    ```\n- **静态同步函数的同步锁**\n    - 该函数所属字节码文件对象，可以用`getClass`方法获取，也可以用当前`类名.class`表示\n    - 相当于\n    ```\n    synchronized(this.getClass / Ticket.class) {\n        ...\n    }\n    ```\n\n### 同步代码块与同步函数的区别\n- 同步函数的锁是固定的`this`\n- 同步代码块的锁可以是任意的对象\n\n*建议使用同步代码块*\n\n## 单例模式的多线程问题 [重要]\n\n```\nclass Single {\n    private static Single s;\n    private Single(){}\n    \n    public static Single getInstance() {\n        if (s == null)\n            -->0 -->1  // 两个线程同时到了这，就会 new 两个对象出来，产生线程安全问题\n            s = new Single();\n        return s;\n    }\n}\n```\n\n##### 解决方法\n\n```\nclass Single {\n    private static Single s;\n    private Single(){}\n    \n    public static Single getInstance() {\n        if (s == null) {                  // 外面的这个 if 判断解决了要进行同步锁判断的效率问题\n            synchronized(Single.class) {  // synchronized 解决了线程安全问题\n                if (s == null)\n                    s = new Single();\n            }\n        }\n        return s;\n    }\n}\n```\n\n## 死锁 [重要]\n\n- 常见情形：同步的嵌套 & 多个锁，不同线程各持一个锁在等待另一个锁，并且都不放开自己已经持有的锁\n- 死锁示例：[DeadLockTest](13_多线程/DeadLockTest.txt)\n\n## 线程间的通信 [重要]\n\n多个线程在处理同一资源，但是任务却不同\n\n\n### 等待唤醒机制\n\n##### 用到的方法（注意：这些方法都必须定义在同步中）\n- `wait()`：让线程处于冻结状态，被`wait()`的线程会被存储到线程池中\n- `notify()`：唤醒线程池中一个线程**(任意)**\n- `notifyAll()`：唤醒线程池中的所有线程\n\n##### NOTE\n- **这些方法都必须定义在同步中**\n    - 原因：因为这些方法是用于操作线程状态的方法，必须要明确**操作的是哪个锁上的线程**，所以这些方法其实是**调用了锁的方法**\n- 因为是调用了锁的方法，所以它们都定义在了`Object`类中\n    - 原因：因为锁可以是任意的对象，任意的对象调用的方式一定定义在`Object`类中\n    \n##### Example（单生产者单消费者问题）\n- 原始版：[ResourceDemo](13_多线程/ResourceDemo.txt)\n- 优化版：[OptimizedResourceDemo](13_多线程/OptimizedResourceDemo.txt)\n\n\n### 多生产者多消费者问题\n\n#### 出现的问题\n##### 问题一\n```\nif (flag)\n    try {wait();} catch (InterruptedException e) {}\n...\n```\n在`wait()`处休眠的线程再次被唤醒后，不会再判断`flag`的值，而是直接往下运行，会导致不该运行的线程运行，出现数据错误的情况\n\n##### 解决方法\n```\nwhile (flag)\n    try {wait();} catch (InterruptedException e) {}\n...\n```\n采用`while`判断标记\n\n##### 问题二\n`notify()`与`while(flag)`的搭配会导致死锁\n\n##### 解决方法\n采用`notifyAll()`解决了本方线程一定会唤醒对方线程的问题\n\n#### Example\n[ProducerConsumerDemo](13_多线程/ProducerConsumerDemo.txt)\n\n\n### jdk1.5 后对多线程的改进\n- `synchronized`中对于锁的操作是隐式的，jdk1.5 以后将同步和锁封装成了对象，将隐式动作变成了显示动作\n- `Lock`接口：替代了同步代码块或者同步函数，将同步的隐式锁操作变成现实锁操作，并且可以在一个锁上加上多组监视器\n    - `lock()`：获取锁。\n    - `unlock()`：释放锁，通常需要定义finally代码块中\n\n```\nLock l = ...;\n\nl.lock();\ntry {\n    // access the resource protected by this lock\n} finally {\n    l.unlock();\n}\n```\n- `Condition`接口：出现替代了`Object`中的`wait()` `notify()` `notifyAll()`方法，将这些监视器方法单独进行了封装，变成`Condition`监视器对象\n    - 替换方法为`await()` `signal()` `signalAll()`\n    \n#### Example\n[JDK1_5_ProducerConsumerDemo](13_多线程/JDK1_5_ProducerConsumerDemo.txt)\n\n#### Docs Example\n```\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n## `wait()`和`sleep()`的区别\n\n- `wait()`可以指定时间也可以不指定，`sleep()`必须指定时间\n- 在同步中时，对 CPU 的执行权和锁的处理不同\n    - `wait()`：释放执行权，释放锁\n    - `sleep()`：释放执行权，不释放锁\n\n## 同步的注意事项\n\n- 同步代码块中可以存活多个线程，但运行的只有一个线程，因为只有一个线程可以拿到锁\n\n```\nclass Demo {\n\tvoid show() {\n\t\tsynchronized(this) {\n\t\t\twait(); // t0 t1 t2 三个线程都在同步代码块中存活，但运行时还是要一个一个运行的\n\t\t}\n\t}\n    \n\tvoid method() {\n\t\tsynchronized(this) { // t4\n\t\t\tnotifyAll();\n\t\t}\n\t}\n}\n```\n\n\n## 停止线程\n\n- `stop()`方法（官方的不推荐使用）\n- `run()`方法结束\n\n##### 怎么控制线程的任务结束呢?\n- 任务中都会有循环结构，只要控制住循环就可以结束任务\n- 控制循环通常就用定义标记来完成\n\n```\nprivate boolean flag;\n\npublic synchronized void run() {\n    while (flag) {\n    ...\n    }\n}\n```\n\n##### 但是如果线程处于了冻结状态，无法读取标记，那应该如何结束呢？\n- 可以使用`interrupt()`方法将线程从冻结状态强制恢复到运行状态中来，让线程具备 cpu 的执行资格\n- 但强制的`interrupt()`动作会抛出`InterruptedException`，记得要处理\n\n##### Example\n[StopThread](13_多线程/StopThread.txt)\n\n## 官方不推荐使用`stop()`和`suspend()`的原因\n### 不推荐使用`stop()`的原因\n- 因为它不安全，会造成数据的不完整\n- 说明\n    - `stop()`会解除由线程获取的所有锁定，当在一个线程对象上调用`stop()`方法时，这个线程对象所运行的线程就会立即停止\n    - 假如一个线程正在执行：`synchronized void { x = 3; y = 4;}`，由于方法是同步的，多个线程访问时总能保证 x，y 被同时赋值，而如果一个线程正在执行到`x = 3;`时，被调用了`stop()`方法，即使在同步块中，它也干脆地 stop 了，这样就产生了不完整的残废数据\n    - 而多线程编程中最最基础的条件是要保证数据的完整性\n\n### 不推荐使用`suspend()`的原因\n- 因为它容易发生死锁\n- 说明\n    - 调用`suspend()`的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定\n    - 此时，其他任何线程都不能访问锁定的资源，除非被“挂起”的线程恢复运行\n    - 对任何线程来说，如果它们想恢复目标线程，同时又试图使用一个锁定的资源，就会造成死锁\n\n## 守护线程（后台线程）\n**`setDaemon()`**\n\n- 当所有剩余运行的线程都是守护线程（后台线程）后，java 虚拟机会退出执行\n    - 即所有的前台线程都结束后，剩下的后台线程就自动结束了\n- 为什么叫“守护线程”\n    - 来自圣斗士星矢，星矢是守护雅典娜的，雅典娜就是前台线程，星矢就是守护线程，如果雅典娜都没了，星矢自然就没有存在的必要了\n- 例子：`t1`和`main`线程结束后，`t2`线程自动结束\n\n```\nStopThread st = new StopThread();\n\nThread t1 = new Thread(st);\nThread t2 = new Thread(st);\n\nt1.start();\nt2.setDaemon(true);\nt2.start();\n```\n\n\n\n## `join()`方法\n\n```\nt0.join();\n```\n\n- `t0`线程要申请加入进来运行\n- 用在临时加入一个线程运算时\n- `join()`方法会使当前运行的线程冻结，直到调用`join()`方法的线程运行完毕后，才再次开始运行\n- 因为有冻结线程的能力，所以会抛出`InterruptedException`异常\n\n## `toString()`方法\n\n##### 输出\n```\nThread[线程名，优先级，线程组]\n```\n\n##### 优先级\n- 优先级范围 1~10，6 7 差距不大，但 1 5 10 差距就比较大了，优先级大只是这个线程的执行频率变高，并不是会一直执行这个线程直至结束\n\n```\nt2.setPriority(Thread.MAX_PRIORITY);\n```\n\n## `yield()`方法\n\n```\nThread.yield();  // 释放执行权\n```\n\n## 两个小问题\n\n##### 问题一\n```\nclass Test implements Runnable {\n\tpublic void run(Thread t){\n    }\n}\n```\n错在没有实现`Runnable`接口的方法\n\n##### 问题二\n```\nclass ThreadTest {\n\tpublic static void main(String[] args) {\n\n\t\tnew Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"runnable run\");\n\t\t\t}\n\t\t}) {\n\t\t\tpublic void run() {\n\t\t\t\tSystem.out.println(\"subThread run\");\n\t\t\t}\n\t\t}.start();\n    }\n}\n```\n输出：`subThread run`，因为以子类方法为主，而`public Thread(Runnable target)`构造器相当于将 Thread 的 parent 赋成 target\n",[[1512705877548,["user@user-PC",[[1,28,"\n"]],[26,26],[27,27]]],[1512705877802,["user@user-PC",[[1,29,"\n"]],[27,27],[28,28]]],[1512705878760,["user@user-PC",[[1,28,"【"]],[28,28],[29,29]]],[1512705879840,["user@user-PC",[[-1,28,"【"]],[29,29],[28,28]]],[1512705881533,["user@user-PC",[[1,28,"[]["]],[28,28],[31,31]]],[1512705882522,["user@user-PC",[[-1,30,"["]],[31,31],[30,30]]],[1512705883632,["user@user-PC",[[1,29,"[]"]],[29,29],[31,31]]],[1512705885351,["user@user-PC",[[1,30,"toc"]],[30,30],[33,33]]]]]]}