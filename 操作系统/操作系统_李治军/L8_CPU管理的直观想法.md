# CPU 管理的直观想法



我们知道，CPU 只要在运行，它就是在做计算的，只要它在做计算，它就是有产出的，贪心的我们肯定是希望我们手里的 CPU 一刻不停的工作。所以 CPU 管理，就是我们想尽各种办法压榨 CPU，让它尽可能的一刻不停的工作。

想要解决这个问题，我们要先来看看 CPU 是如何工作的，通过它的工作方式分析出为什么它不能一直工作，然后再想办法看看怎么能利用起来它不工作的时间，以提高它工作的总时长（感觉我们好坏…… CPU 比 996.icu 惨多了……）。



## CPU 工作原理

想要理解 CPU 的工作原理，我们首先需要知道一个叫 PC 指针的东西。

> PC 指针（Program Counter），存放的是下一步要访问的内存地址，一般 CPU 里是有专门的一个寄存器来放它的。

也就是说，PC 指针就是一个指挥棒，它指哪，CPU 就算哪。因此我们可以得到如下的 **CPU 工作流程：**

- 设置好 PC 指针指向程序的开始；
- 从 PC 指针指向的地址取出下一条要执行的指令；
- 执行这条指令，CPU 就跑去算 这条指令了；
- 算完之后，PC = PC + 1，会继续执行程序的下一条指令了（如果有跳转的另算）。

上面的工作流程又称为 CPU 的取址执行。



## 那 CPU 为什么不能一直工作呢？

因为有 IO 呀！

如果程序中有 `printf` 啥的，程序会跑超慢的，为啥？因为 CPU 算数都是上电的，老快了，可是磁盘操作是机械操作，一次 IO 操作可能比一次 CPU 计算慢上 `10^6` 倍，那么如果 CPU 就一直线性跑一个程序，在碰到 IO 的时候，它就只能在那里等 IO 结束。因此，如果 CPU 一直线性跑的话，它可能把大部分时间都花在等 IO 的结果了。

但这也给了我们压榨 CPU 的可能，我们可以在 CPU 等这个程序的 IO 执行的时候，把 CPU 派去执行其他的程序！

也就是说，让 CPU 一直工作的秘籍就是： **让一个 CPU 交替执行多个程序，也就是并发！**



## 如何把 CPU 切去执行执行其他程序呢？

根据以上的分析，我们要将 CPU 切去执行其他程序，只要改一下 PC 就好了，这样 CPU 就在一个新的程序上自动取值执行了。可是我们只改一下 PC 就可以了吗？显然不可以，我们还需要将上下文切换为当前的程序的，我们可以认为：

```
进程 = 运行中的程序 = 程序代码 + 上下文
```

所以切换 CPU 执行其他程序的时候，还需要将上下文也切换为另一个程序的。



> **线程上下文切换和进程上下文切换的区别**
>
> 最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。
>
> 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。

