# 分布式锁

分布式锁，就是在分布式的环境中，我们本地的如 ReentrantLock 之流的加锁方式不好使了，我们需要开发一种新锁，让我们在分布式环境中也能实现本地锁的效果。

## 概述

### 为啥需要分布式锁

分布式锁的两个应用场景：

- 提高效率：使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。
- 保证正确性：加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。

### 分布式锁的特点

- **互斥性**：和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。
- **可重入性**：同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。
- **锁超时**：和本地锁一样支持锁超时，防止死锁。
- **高效，高可用**：加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。
- **支持阻塞和非阻塞**：和 ReentrantLock 一样支持 lock 和 trylock 以及 tryLock(long timeOut)。
- **支持公平锁和非公平锁 (可选)**：公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。

### 常见分布式锁

- MySQL
- Zookeeper
- Redis
- 自研分布式锁：如谷歌的 Chubby

## MySQL 分布式锁

先建一个锁表：

```mysql
...
```

### 小结

- **适用场景**：MySQL 分布式锁一般适用于资源不存在数据库，如果数据库存在比如订单，那么可以直接对这条数据加行锁，不需要我们上面多的繁琐的步骤，比如一个订单，那么我们可以用 `select * from order_table where id = 'xxx' for update` 进行加行锁，那么其他的事务就不能对其进行修改。
- **优点**：理解起来简单，不需要维护额外的第三方中间件 (比如Redis, Zk)。
- **缺点**：虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。



参考：

- https://juejin.im/post/5bbb0d8df265da0abd3533a5