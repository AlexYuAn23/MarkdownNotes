# Java 基础常见面试题



## Java 的四个基本特性，在项目中那些地方用到多态

- 抽象
- 封装
- 继承
- 多态



## 方法的重载和重写

首先，它们的共同点就是 **方法名一定要相同** ！区别在于：

- **重载：** 发生在同一个类中，参数必须不同（类型 or 个数 or 顺序，不包括返回参数），方法返回值和访问修饰符可以不同，发生在编译时。
- **重写：** 发生在父子类中，参数列表必须相同，返回值范围和抛出的异常范围小于等于父类，访问修饰符范围大于等于父类（如果父类方法访问修饰符为 private 则子类就不能重写该方法），发生在运行时。

除此之外，重载与重写的实现方式也很不一样，它们的区别在于方法分派上，方法分派就是在方法调用前，确定要调用的方法到底是哪一个，它的实际入口地址到底在哪，而 **重载是基于方法的静态分派实现的，重写是基于方法的动态分派实现的** 。

那么什么是方法的静态分派和动态分派呢？[详见这里](https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.md#%E5%88%86%E6%B4%BE%E8%B0%83%E7%94%A8)。

为了不影响阅读，在这里再简单总结下：

- 静态分派：编译时，通过方法的参数（类型 & 个数 & 顺序）这种静态的东西来判断到底调用哪个方法。
- 动态分派：运行时，通过方法的接收者这种动态的东西来判断到底调用哪个方法。

通过以上两条，我们也能得出为什么重载是基于方法的静态分派实现的，重写是基于方法的动态分派实现的了。



## 自动装箱与拆箱

- **装箱：** 将基本类型用它们对应的引用类型包装起来；
- **拆箱：** 将包装类型转换为基本数据类型；



## == 与 equals

== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是
值，引用数据类型==比较的是内存地址)





## 面向对象和面向过程的区别？用面向过程可以实现面向对象吗？





## 接口和抽象类的区别





## static 和 final 的区别和用途





## Object 类的常见方法总结





## String、StringBuffer、StringBuilder 以及对 String 不变性的理解

### String、StringBuffer、StringBuilder





### String 不变性的理解





### String 有重写 Obiect 的 hashcode 和 toString 吗？





### 如果重写 equals 不重写 hashcode 会出现什么问题？







## Java 序列化

### 如何实现序列化和反序列化



### 常见的序列化协议





## Java 多线程的三种方式及其区别







## 什么是线程安全







## 多线程如何进行信息交互







## 多线程共用一个数据变量需要注意什么？







## 线程池

### 什么是线程池？



### 如果让你设计一个动态大小的线程池，如何设计，有哪些方法？





## Java 是否有内存泄露和内存溢出的风险







## 异常

### 常见异常分为哪两种

Exception 和 Error。

### 常见异常的基类以及常见的异常





## Java 中的 NIO，BIO，AIO 分别是什么？







## 匿名内部类是什么？如何访问在其外面定义的变量？







## 泛型







## Java 枚举类







## Java 反射







## Java 动态代理







## 为什么要实现内存模型？



