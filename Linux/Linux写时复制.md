# Linux 写时复制（Copy on Write，CoW）

> **exec() 系统调用：**
>
> 对当前进程进行替换，替换者为一个指定的程序，其参数包括文件名 (filename)、参数列表 (argv)以及环境变量 (envp)。
>
> 一个进程一旦调用了 exec 族函数，这个进程的本质上就死掉了，虽然它的 PID 并没有发生变化，但是它执行的程序已经变成另一个了。系统会将代码替换为新的程序的代码，废弃原有的数据段和堆栈段，为新的程序分配新的数据段和堆栈段。
>
> 和穿越差不多，这个进程本身就是肉身，以前运行的程序是以前的灵魂，因为意外，那个灵魂死掉了，现在穿越来了一个新的灵魂（现在运行的程序）。
>
> 在 Linux 中，exec 函数族有 6 个成员：execl，execlp，execle，execv，execve、execvp。

`exec()` 和 `fork()` 经常搭配使用，用来创建新的子进程，先调用 `fork()` 复制父进程，然后调用 `exec()` 将复制来的进程运行的程序替换为子进程要运行的程序，代码如下：

```c
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>

char command[256];
void main() {
    int rtn; /*子进程的返回数值*/
    while(1) {
        /* 从终端读取要执行的命令 */
        printf( ">" );
        fgets( command, 256, stdin );
        command[strlen(command)-1] = 0;
        if ( fork() == 0 ) {/* 子进程执行此命令 */
            execlp( command, NULL );
            /* 如果exec函数返回，表明没有正常执行命令，打印错误信息*/
            perror( command );
            exit( errno );
        }
        else {/* 父进程， 等待子进程结束，并打印子进程的返回值 */
            wait ( &rtn );
            printf( " child process return %d\n", rtn );
        }
    }
}
```

**什么是写时复制？**

Linux 系统出与效率的考量，使用了写时复制技术，也就是说，只有进程空间的各段内容要发生变化时，才会将父进程的内容复制一份给子进程。也就是说，在执行 `fork()` 之后，`exec()` 之前，子进程与父进程是共用相同的物理空间（内存区）的，子进程的代码段，数据段，堆栈都是个指针，指向父进程的物理空间，这样尽管两个进程的虚拟空间不同，但是其对应的物理空间还是同一个。

只有当父进程或子进程中有更改相应段的行为时，才会为子进程的相应段分配新的物理空间，并复制数据。也就是说，如果不调用 `exec()`，即子进程与父进程运行的代码没有发生变化，内核会给子进程的数据段和堆栈段分配相应的物理空间，而代码段则继续共用相同的物理空间，而如果调用了 `exec()`，代码段也会发生变化，子进程就需要给代码段分配单独的物理空间了。

**写时复制的优点？**

传统的 `fork()` 系统调用直接把所有的资源复制给新创建的进程，此时，一旦新进程打算立即执行一个新的映像，那么此前做的所有的拷贝操作都是没有任何意义的。比如调用完 `fork()` 后立即调用 `exec()`，就无需将父进程的地址空间复制一遍再删掉了，可以避免拷贝大量根本就不会使用的数据。



参考：https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html