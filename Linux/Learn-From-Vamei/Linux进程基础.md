# Linux 进程基础

进程，这是 Linux 系统中很重要的一个概念（应该是所有操作系统中……），那么什么是进程呢？这得让我们从头说起。

先来说说操作系统运行的地方：电脑。

我们拿电脑，一般就是用来运行程序，如果你只是一个普通的用户，那么你拿电脑可能一半都是运行别人写好的程序，并且你会管别人写好的程序叫做软件，但是，如果你也和我一样，是一个程序员，那么你还会拿电脑去运行自己写的程序，反正，总而言之，我们是要拿电脑去运行程序的才能发挥一个电脑的价值的。

可是电脑有时怎么运行我们的程序的呢？？？

我们写的代码只是一个静态的文本文件，这东西放到电脑里一跑，咋就变成一个有用的软件了呢？这就涉及到了 **程序** 和 **进程** 的区别了。简单来说，**进程是程序的一个具体实现，是动态的程序**。

程序就是一系列指令的所构成的集合，通过以一定的顺序执行这些指令，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件，根据 Vamei 大神的比喻，我们可以将一个可执行文件比喻成一个菜谱，只有菜谱时没什么用的，我们要根据菜谱的指点一步一步的真正执行，才能做出美味的饭菜来。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。

同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。

这么说来说去的，感觉进程还是一个很飘渺的东西，没什么实感，那么，打开你的 Linux 系统，执行 `ps` 命令来看看吧！

```shell
ps -eo pid,ppid,comm,cmd  # (-e 表示列出全部进程，-o pid,ppid,comm,cmd 表示我们需要 PID，COMMAND，CMD 信息)
# 输出
  PID  PPID COMMAND         CMD
    1     0 systemd         /sbin/init
    2     0 kthreadd        [kthreadd]
  ...
```

我们可以看到，第一行有一个 pid=1 叫做 init 的进程，这个进程是执行 /sbin/bin 生成的。其实，当 Linux 启动时，init 是系统创建的第一个进程，这个进程会一直存在着，直到我们关闭计算机。这个进程十分的重要，它是在它之后创建的所有进程的祖先。



## 如何创建一个进程

当我们打开电脑时，内核只创建了一个 init 进程，之后，Linux 内核将不再提供之间新建进程的系统调用，剩下的所有进程都是 init 进程通过 fork 机制建立的。也就是说，**新的进程要通过老的进程复制自身得到，这就是 fork。** 

fork 是一个系统调用，每个进程都在内存中分配有属于自己的一片空间，当进程 fork 的时候，Linux 在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。

老进程成为新进程的父进程，而相应的，新进程就是老的进程的子进程。因此，一个进程除了有一个 PID 之外，还会有一个PPID (parent PID) 来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。

**fork 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。** 实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。

通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令，比如说使用 exec 库函数读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的：为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。



## 子进程的终结

**当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息** (exit code，如果顺利运行，为0；如果有错误或异常状况，为 >0 的整数)，这个信息会解释该进程为什么退出。

**父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。** 这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，**如果父进程早于子进程终结，子进程就会成为一个孤儿进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。**

当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。



## 线程与进程

在 Linux 中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和 IO 接口。所以，进程是 Linux 程序的唯一的实现方式。



参考：https://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html