# Linux 进程基础

进程，这是 Linux 系统中很重要的一个概念（应该是所有操作系统中……），那么什么是进程呢？这得让我们从头说起。

先来说说操作系统运行的地方：电脑。

我们拿电脑，一般就是用来运行程序，如果你只是一个普通的用户，那么你拿电脑可能一半都是运行别人写好的程序，并且你会管别人写好的程序叫做软件，但是，如果你也和我一样，是一个程序员，那么你还会拿电脑去运行自己写的程序，反正，总而言之，我们是要拿电脑去运行程序的才能发挥一个电脑的价值的。

可是电脑有时怎么运行我们的程序的呢？？？

我们写的代码只是一个静态的文本文件，这东西放到电脑里一跑，咋就变成一个有用的软件了呢？这就涉及到了 **程序** 和 **进程** 的区别了。简单来说，**进程是程序的一个具体实现，是动态的程序**。

程序就是一系列指令的所构成的集合，通过以一定的顺序执行这些指令，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件，根据 Vamei 大神的比喻，我们可以将一个可执行文件比喻成一个菜谱，只有菜谱时没什么用的，我们要根据菜谱的指点一步一步的真正执行，才能做出美味的饭菜来。进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。

同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。不同的进程还可以拥有各自独立的 IO 接口。

这么说来说去的，感觉进程还是一个很飘渺的东西，没什么实感，那么，打开你的 Linux 系统，执行 `ps` 命令来看看吧！

```shell
ps -eo pid,ppid,comm,cmd  # (-e 表示列出全部进程，-o pid,ppid,comm,cmd 表示我们需要 PID，COMMAND，CMD 信息)
# 输出
  PID  PPID COMMAND         CMD
    1     0 systemd         /sbin/init
    2     0 kthreadd        [kthreadd]
  ...
```

我们可以看到，第一行有一个 pid=1 叫做 init 的进程，这个进程是执行 /sbin/bin 生成的。其实，当 Linux 启动时，init 是系统创建的第一个进程，这个进程会一直存在着，直到我们关闭计算机。这个进程十分的重要，它是在它之后创建的所有进程的祖先。



## 如何创建一个进程

当我们打开电脑时，内核只创建了一个 init 进程，之后，Linux 内核将不再提供之间新建进程的系统调用，剩下的所有进程都是 init 进程通过 fork 机制建立的。也就是说，**新的进程要通过老的进程复制自身得到，这就是 fork。** 

fork 是一个系统调用，每个进程都在内存中分配有属于自己的一片空间，当进程 fork 的时候，Linux 在内存中开辟出一片新的内存空间给新的进程，并将老的进程空间中的内容复制到新的空间中，此后两个进程同时运行。

老进程成为新进程的父进程，而相应的，新进程就是老的进程的子进程。因此，一个进程除了有一个 PID 之外，还会有一个PPID (parent PID) 来存储的父进程 PID。如果我们循着 PPID 不断向上追溯的话，总会发现其源头是 init 进程。所以说，所有的进程也构成一个以 init 为根的树状结构。

**fork 通常作为一个函数被调用。这个函数会有两次返回，将子进程的 PID 返回给父进程，0 返回给子进程。** 实际上，子进程总可以查询自己的 PPID 来知道自己的父进程是谁，这样，一对父进程和子进程就可以随时查询对方。

通常在调用 fork 函数之后，程序会设计一个 if 选择结构。当 PID 等于 0 时，说明该进程为子进程，那么让它执行某些指令，比如说使用 exec 库函数读取另一个程序文件，并在当前的进程空间执行 (这实际上是我们使用 fork 的一大目的：为某一程序创建进程)；而当 PID 为一个正整数时，说明为父进程，则执行另外一些指令。由此，就可以在子进程建立之后，让它执行与父进程不同的功能。



## 子进程的终结

**当子进程终结时，它会通知父进程，并清空自己所占据的内存，并在内核里留下自己的退出信息** (exit code，如果顺利运行，为0；如果有错误或异常状况，为 >0 的整数)，这个信息会解释该进程为什么退出。

**父进程在得知子进程终结时，有责任对该子进程使用 wait 系统调用。** 这个 wait 函数能从内核中取出子进程的退出信息，并清空该信息在内核中所占据的空间。但是，**如果父进程早于子进程终结，子进程就会成为一个孤儿进程。孤儿进程会被过继给 init 进程，init 进程也就成了该进程的父进程。init 进程负责该子进程终结时调用 wait 函数。**

当然，一个糟糕的程序也完全可能造成子进程的退出信息滞留在内核中的状况（父进程不对子进程调用 wait 函数），这样的情况下，子进程成为僵尸（zombie）进程。当大量僵尸进程积累时，内存空间会被挤占。



## Linux 下的特殊进程

Linux 下有 3 个特殊进程：

- idle 进程（PID = 0）
	- 由系统自动创建，运行在内核态，其前身是系统创建的第一个进程；
	- 是唯一一个没有通过 fork 或 kernel_thread 产生的进程。
- init 进程（PID = 1）
	- 由 idle 进程通过 kernel_thread 创建，是系统中所有其他用户的祖先进程；
	- Linux 中的所有进程都是由 init 进程创建并运行的；
	- 系统启动完成后，init 进程将变为守护进程，监视其他进程。
- kthreadd 进程（PID = 2）
	- 由 idle 通过 kernel_thread 创建，并始终运行在内核空间，负责所有内核线程的调度和管理；
	- 它的任务就是管理和调度其他内核线程 kernel_thread，会循环执行一个 kthread 的函数，该函数的作用就是运行 kthread_create_list 全局链表中维护的 kthread，我们调用 kernel_thread 创建的内核线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以 kthreadd 为父进程

### init 进程

是 Linux 内核开始建立起进程概念时第一个通过 kernel_thread 产生的进程，其开始在内核态执行，然后通过一个系统调用，开始执行用户空间的 /sbin/init 程序，其间，Linux 内核也经历了从内核态到用户态的特权级转变，/sbin/init 极有可能产生出了shell，然后所有的用户进程都由该进程派生出来。

0 号进程创建 1 号进程的方式如下：

```c
kernel_thread(kernel_init, NULL, CLONE_FS);
```

随后，1 号进程调用 do_execve 运行可执行程序 init，并演变成用户态 1 号进程，即 init 进程。

init 进程是 linux 内核启动的第一个用户级进程。init 有许多很重要的任务，比如像启动 getty（用于用户登录）、实现运行级别、以及处理孤立进程等。



## 僵尸进程

一个子进程在其父进程还没有调用 wait() 或 waitpid() 的情况下退出。这个子进程就是僵尸进程。

**产生僵尸进程的原因：**

- 子进程结束后向父进程发出 SIGCHLD 信号，父进程默认忽略了它；
- 父进程没有调用 wait() 或 waitpid() 函数来等待子进程的结束。

**处理办法：**

- 把父进程杀掉，僵尸进程会变成孤儿进程，然后过继给1号进程，而1号进程会扫描名下子进程，把 Z 状态进程回收；



## 线程与进程

在 Linux 中，线程只是一种特殊的进程。多个线程之间可以共享内存空间和 IO 接口。所以，进程是 Linux 程序的唯一的实现方式。



参考：

- [Linux进程基础](https://www.cnblogs.com/vamei/archive/2012/09/20/2694466.html)
- [Linux下1号进程的前世(kernel_init)今生(init进程)----Linux进程的管理与调度（六）](https://blog.csdn.net/gatieme/article/details/51532804)
- 